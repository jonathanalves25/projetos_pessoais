{"ast":null,"code":"var CLASS_PART_SEPARATOR = '-';\n\nfunction createClassUtils(config) {\n  var classMap = createClassMap(config);\n\n  function getClassGroupId(className) {\n    var classParts = className.split(CLASS_PART_SEPARATOR); // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.\n\n    if (classParts[0] === '' && classParts.length !== 1) {\n      classParts.shift();\n    }\n\n    return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className);\n  }\n\n  function getConflictingClassGroupIds(classGroupId) {\n    return config.conflictingClassGroups[classGroupId] || [];\n  }\n\n  return {\n    getClassGroupId: getClassGroupId,\n    getConflictingClassGroupIds: getConflictingClassGroupIds\n  };\n}\n\nfunction getGroupRecursive(classParts, classPartObject) {\n  var _classPartObject$vali;\n\n  if (classParts.length === 0) {\n    return classPartObject.classGroupId;\n  }\n\n  var currentClassPart = classParts[0];\n  var nextClassPartObject = classPartObject.nextPart.get(currentClassPart);\n  var classGroupFromNextClassPart = nextClassPartObject ? getGroupRecursive(classParts.slice(1), nextClassPartObject) : undefined;\n\n  if (classGroupFromNextClassPart) {\n    return classGroupFromNextClassPart;\n  }\n\n  if (classPartObject.validators.length === 0) {\n    return undefined;\n  }\n\n  var classRest = classParts.join(CLASS_PART_SEPARATOR);\n  return (_classPartObject$vali = classPartObject.validators.find(function (_ref) {\n    var validator = _ref.validator;\n    return validator(classRest);\n  })) == null ? void 0 : _classPartObject$vali.classGroupId;\n}\n\nvar arbitraryPropertyRegex = /^\\[(.+)\\]$/;\n\nfunction getGroupIdForArbitraryProperty(className) {\n  if (arbitraryPropertyRegex.test(className)) {\n    var arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)[1];\n    var property = arbitraryPropertyClassName == null ? void 0 : arbitraryPropertyClassName.substring(0, arbitraryPropertyClassName.indexOf(':'));\n\n    if (property) {\n      // I use two dots here because one dot is used as prefix for class groups in plugins\n      return 'arbitrary..' + property;\n    }\n  }\n}\n/**\r\n * Exported for testing only\r\n */\n\n\nfunction createClassMap(config) {\n  var theme = config.theme,\n      prefix = config.prefix;\n  var classMap = {\n    nextPart: new Map(),\n    validators: []\n  };\n  var prefixedClassGroupEntries = getPrefixedClassGroupEntries(Object.entries(config.classGroups), prefix);\n  prefixedClassGroupEntries.forEach(function (_ref2) {\n    var classGroupId = _ref2[0],\n        classGroup = _ref2[1];\n    processClassesRecursively(classGroup, classMap, classGroupId, theme);\n  });\n  return classMap;\n}\n\nfunction processClassesRecursively(classGroup, classPartObject, classGroupId, theme) {\n  classGroup.forEach(function (classDefinition) {\n    if (typeof classDefinition === 'string') {\n      var classPartObjectToEdit = classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition);\n      classPartObjectToEdit.classGroupId = classGroupId;\n      return;\n    }\n\n    if (typeof classDefinition === 'function') {\n      if (isThemeGetter(classDefinition)) {\n        processClassesRecursively(classDefinition(theme), classPartObject, classGroupId, theme);\n        return;\n      }\n\n      classPartObject.validators.push({\n        validator: classDefinition,\n        classGroupId: classGroupId\n      });\n      return;\n    }\n\n    Object.entries(classDefinition).forEach(function (_ref3) {\n      var key = _ref3[0],\n          classGroup = _ref3[1];\n      processClassesRecursively(classGroup, getPart(classPartObject, key), classGroupId, theme);\n    });\n  });\n}\n\nfunction getPart(classPartObject, path) {\n  var currentClassPartObject = classPartObject;\n  path.split(CLASS_PART_SEPARATOR).forEach(function (pathPart) {\n    if (!currentClassPartObject.nextPart.has(pathPart)) {\n      currentClassPartObject.nextPart.set(pathPart, {\n        nextPart: new Map(),\n        validators: []\n      });\n    }\n\n    currentClassPartObject = currentClassPartObject.nextPart.get(pathPart);\n  });\n  return currentClassPartObject;\n}\n\nfunction isThemeGetter(func) {\n  return func.isThemeGetter;\n}\n\nfunction getPrefixedClassGroupEntries(classGroupEntries, prefix) {\n  if (!prefix) {\n    return classGroupEntries;\n  }\n\n  return classGroupEntries.map(function (_ref4) {\n    var classGroupId = _ref4[0],\n        classGroup = _ref4[1];\n    var prefixedClassGroup = classGroup.map(function (classDefinition) {\n      if (typeof classDefinition === 'string') {\n        return prefix + classDefinition;\n      }\n\n      if (typeof classDefinition === 'object') {\n        return Object.fromEntries(Object.entries(classDefinition).map(function (_ref5) {\n          var key = _ref5[0],\n              value = _ref5[1];\n          return [prefix + key, value];\n        }));\n      }\n\n      return classDefinition;\n    });\n    return [classGroupId, prefixedClassGroup];\n  });\n}\n\nexport { createClassMap, createClassUtils };","map":{"version":3,"mappings":"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","names":["CLASS_PART_SEPARATOR","createClassUtils","config","classMap","createClassMap","getClassGroupId","className","classParts","split","length","shift","getGroupRecursive","getGroupIdForArbitraryProperty","getConflictingClassGroupIds","classGroupId","conflictingClassGroups","classPartObject","currentClassPart","nextClassPartObject","nextPart","get","classGroupFromNextClassPart","slice","undefined","validators","classRest","join","find","validator","_classPartObject$vali","arbitraryPropertyRegex","test","arbitraryPropertyClassName","exec","property","substring","indexOf","theme","prefix","Map","prefixedClassGroupEntries","getPrefixedClassGroupEntries","Object","entries","classGroups","forEach","_ref2","classGroup","processClassesRecursively","classDefinition","classPartObjectToEdit","getPart","isThemeGetter","push","_ref3","key","path","currentClassPartObject","pathPart","has","set","func","classGroupEntries","map","_ref4","prefixedClassGroup","fromEntries","value"],"sources":["/Users/johnny/git/projetos_pessoais/calculadora-imc/node_modules/tailwind-merge/src/lib/class-utils.ts"],"sourcesContent":["import { ClassGroupId, Config, ClassGroup, ClassValidator, ThemeObject, ThemeGetter } from './types'\n\nexport interface ClassPartObject {\n    nextPart: Map<string, ClassPartObject>\n    validators: ClassValidatorObject[]\n    classGroupId?: ClassGroupId\n}\n\ninterface ClassValidatorObject {\n    classGroupId: ClassGroupId\n    validator: ClassValidator\n}\n\nconst CLASS_PART_SEPARATOR = '-'\n\nexport function createClassUtils(config: Config) {\n    const classMap = createClassMap(config)\n\n    function getClassGroupId(className: string) {\n        const classParts = className.split(CLASS_PART_SEPARATOR)\n\n        // Classes like `-inset-1` produce an empty string as first classPart. We assume that classes for negative values are used correctly and remove it from classParts.\n        if (classParts[0] === '' && classParts.length !== 1) {\n            classParts.shift()\n        }\n\n        return getGroupRecursive(classParts, classMap) || getGroupIdForArbitraryProperty(className)\n    }\n\n    function getConflictingClassGroupIds(classGroupId: ClassGroupId) {\n        return config.conflictingClassGroups[classGroupId] || []\n    }\n\n    return {\n        getClassGroupId,\n        getConflictingClassGroupIds,\n    }\n}\n\nfunction getGroupRecursive(\n    classParts: string[],\n    classPartObject: ClassPartObject,\n): ClassGroupId | undefined {\n    if (classParts.length === 0) {\n        return classPartObject.classGroupId\n    }\n\n    const currentClassPart = classParts[0]!\n    const nextClassPartObject = classPartObject.nextPart.get(currentClassPart)\n    const classGroupFromNextClassPart = nextClassPartObject\n        ? getGroupRecursive(classParts.slice(1), nextClassPartObject)\n        : undefined\n\n    if (classGroupFromNextClassPart) {\n        return classGroupFromNextClassPart\n    }\n\n    if (classPartObject.validators.length === 0) {\n        return undefined\n    }\n\n    const classRest = classParts.join(CLASS_PART_SEPARATOR)\n\n    return classPartObject.validators.find(({ validator }) => validator(classRest))?.classGroupId\n}\n\nconst arbitraryPropertyRegex = /^\\[(.+)\\]$/\n\nfunction getGroupIdForArbitraryProperty(className: string) {\n    if (arbitraryPropertyRegex.test(className)) {\n        const arbitraryPropertyClassName = arbitraryPropertyRegex.exec(className)![1]\n        const property = arbitraryPropertyClassName?.substring(\n            0,\n            arbitraryPropertyClassName.indexOf(':'),\n        )\n\n        if (property) {\n            // I use two dots here because one dot is used as prefix for class groups in plugins\n            return 'arbitrary..' + property\n        }\n    }\n}\n\n/**\n * Exported for testing only\n */\nexport function createClassMap(config: Config) {\n    const { theme, prefix } = config\n    const classMap: ClassPartObject = {\n        nextPart: new Map<string, ClassPartObject>(),\n        validators: [],\n    }\n\n    const prefixedClassGroupEntries = getPrefixedClassGroupEntries(\n        Object.entries(config.classGroups),\n        prefix,\n    )\n\n    prefixedClassGroupEntries.forEach(([classGroupId, classGroup]) => {\n        processClassesRecursively(classGroup, classMap, classGroupId, theme)\n    })\n\n    return classMap\n}\n\nfunction processClassesRecursively(\n    classGroup: ClassGroup,\n    classPartObject: ClassPartObject,\n    classGroupId: ClassGroupId,\n    theme: ThemeObject,\n) {\n    classGroup.forEach((classDefinition) => {\n        if (typeof classDefinition === 'string') {\n            const classPartObjectToEdit =\n                classDefinition === '' ? classPartObject : getPart(classPartObject, classDefinition)\n            classPartObjectToEdit.classGroupId = classGroupId\n            return\n        }\n\n        if (typeof classDefinition === 'function') {\n            if (isThemeGetter(classDefinition)) {\n                processClassesRecursively(\n                    classDefinition(theme),\n                    classPartObject,\n                    classGroupId,\n                    theme,\n                )\n                return\n            }\n\n            classPartObject.validators.push({\n                validator: classDefinition,\n                classGroupId,\n            })\n\n            return\n        }\n\n        Object.entries(classDefinition).forEach(([key, classGroup]) => {\n            processClassesRecursively(\n                classGroup,\n                getPart(classPartObject, key),\n                classGroupId,\n                theme,\n            )\n        })\n    })\n}\n\nfunction getPart(classPartObject: ClassPartObject, path: string) {\n    let currentClassPartObject = classPartObject\n\n    path.split(CLASS_PART_SEPARATOR).forEach((pathPart) => {\n        if (!currentClassPartObject.nextPart.has(pathPart)) {\n            currentClassPartObject.nextPart.set(pathPart, {\n                nextPart: new Map(),\n                validators: [],\n            })\n        }\n\n        currentClassPartObject = currentClassPartObject.nextPart.get(pathPart)!\n    })\n\n    return currentClassPartObject\n}\n\nfunction isThemeGetter(func: ClassValidator | ThemeGetter): func is ThemeGetter {\n    return (func as ThemeGetter).isThemeGetter\n}\n\nfunction getPrefixedClassGroupEntries(\n    classGroupEntries: Array<[classGroupId: string, classGroup: ClassGroup]>,\n    prefix: string | undefined,\n): Array<[classGroupId: string, classGroup: ClassGroup]> {\n    if (!prefix) {\n        return classGroupEntries\n    }\n\n    return classGroupEntries.map(([classGroupId, classGroup]) => {\n        const prefixedClassGroup = classGroup.map((classDefinition) => {\n            if (typeof classDefinition === 'string') {\n                return prefix + classDefinition\n            }\n\n            if (typeof classDefinition === 'object') {\n                return Object.fromEntries(\n                    Object.entries(classDefinition).map(([key, value]) => [prefix + key, value]),\n                )\n            }\n\n            return classDefinition\n        })\n\n        return [classGroupId, prefixedClassGroup]\n    })\n}\n"]},"metadata":{},"sourceType":"module"}