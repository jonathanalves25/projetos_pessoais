{"ast":null,"code":"var SPLIT_CLASSES_REGEX = /\\s+/;\nvar IMPORTANT_MODIFIER = '!';\n\nfunction mergeClassList(classList, configUtils) {\n  var getClassGroupId = configUtils.getClassGroupId,\n      getConflictingClassGroupIds = configUtils.getConflictingClassGroupIds;\n  /**\r\n   * Set of classGroupIds in following format:\r\n   * `{importantModifier}{variantModifiers}{classGroupId}`\r\n   * @example 'float'\r\n   * @example 'hover:focus:bg-color'\r\n   * @example 'md:!pr'\r\n   */\n\n  var classGroupsInConflict = new Set();\n  return classList.trim().split(SPLIT_CLASSES_REGEX).map(function (originalClassName) {\n    var _splitModifiers = splitModifiers(originalClassName),\n        modifiers = _splitModifiers.modifiers,\n        hasImportantModifier = _splitModifiers.hasImportantModifier,\n        baseClassName = _splitModifiers.baseClassName;\n\n    var classGroupId = getClassGroupId(baseClassName);\n\n    if (!classGroupId) {\n      return {\n        isTailwindClass: false,\n        originalClassName: originalClassName\n      };\n    }\n\n    var variantModifier = sortModifiers(modifiers).join('');\n    var modifierId = hasImportantModifier ? variantModifier + IMPORTANT_MODIFIER : variantModifier;\n    return {\n      isTailwindClass: true,\n      modifierId: modifierId,\n      classGroupId: classGroupId,\n      originalClassName: originalClassName\n    };\n  }).reverse() // Last class in conflict wins, so we need to filter conflicting classes in reverse order.\n  .filter(function (parsed) {\n    if (!parsed.isTailwindClass) {\n      return true;\n    }\n\n    var modifierId = parsed.modifierId,\n        classGroupId = parsed.classGroupId;\n    var classId = modifierId + classGroupId;\n\n    if (classGroupsInConflict.has(classId)) {\n      return false;\n    }\n\n    classGroupsInConflict.add(classId);\n    getConflictingClassGroupIds(classGroupId).forEach(function (group) {\n      return classGroupsInConflict.add(modifierId + group);\n    });\n    return true;\n  }).reverse().map(function (parsed) {\n    return parsed.originalClassName;\n  }).join(' ');\n}\n\nvar SPLIT_MODIFIER_REGEX = /[:[\\]]/g;\n\nfunction splitModifiers(className) {\n  var modifiers = [];\n  var bracketDepth = 0;\n  var modifierStart = 0;\n  var match;\n\n  while (match = SPLIT_MODIFIER_REGEX.exec(className)) {\n    if (match[0] === ':') {\n      if (bracketDepth === 0) {\n        var nextModifierStart = match.index + 1;\n        modifiers.push(className.substring(modifierStart, nextModifierStart));\n        modifierStart = nextModifierStart;\n      }\n    } else if (match[0] === '[') {\n      bracketDepth++;\n    } else if (match[0] === ']') {\n      bracketDepth--;\n    }\n  }\n\n  var baseClassNameWithImportantModifier = modifiers.length === 0 ? className : className.substring(modifierStart);\n  var hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER);\n  var baseClassName = hasImportantModifier ? baseClassNameWithImportantModifier.substring(1) : baseClassNameWithImportantModifier;\n  return {\n    modifiers: modifiers,\n    hasImportantModifier: hasImportantModifier,\n    baseClassName: baseClassName\n  };\n}\n/**\r\n * Sorts modifiers according to following schema:\r\n * - Predefined modifiers are sorted alphabetically\r\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\r\n */\n\n\nfunction sortModifiers(modifiers) {\n  if (modifiers.length <= 1) {\n    return modifiers;\n  }\n\n  var sortedModifiers = [];\n  var unsortedModifiers = [];\n  modifiers.forEach(function (modifier) {\n    var isArbitraryVariant = modifier[0] === '[';\n\n    if (isArbitraryVariant) {\n      sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort().concat([modifier]));\n      unsortedModifiers = [];\n    } else {\n      unsortedModifiers.push(modifier);\n    }\n  });\n  sortedModifiers.push.apply(sortedModifiers, unsortedModifiers.sort());\n  return sortedModifiers;\n}\n\nexport { mergeClassList };","map":{"version":3,"mappings":"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","names":["SPLIT_CLASSES_REGEX","IMPORTANT_MODIFIER","classList","configUtils","getClassGroupId","getConflictingClassGroupIds","classGroupsInConflict","Set","trim","split","map","originalClassName","splitModifiers","modifiers","hasImportantModifier","baseClassName","classGroupId","isTailwindClass","variantModifier","sortModifiers","join","modifierId","reverse","filter","parsed","classId","has","add","forEach","group","SPLIT_MODIFIER_REGEX","className","bracketDepth","modifierStart","match","exec","nextModifierStart","index","push","substring","baseClassNameWithImportantModifier","length","startsWith","sortedModifiers","unsortedModifiers","modifier","isArbitraryVariant","sort"],"sources":["/Users/johnny/git/projetos_pessoais/calculadora-imc/node_modules/tailwind-merge/src/lib/merge-classlist.ts"],"sourcesContent":["import { ConfigUtils } from './config-utils'\n\nconst SPLIT_CLASSES_REGEX = /\\s+/\nconst IMPORTANT_MODIFIER = '!'\n\nexport function mergeClassList(classList: string, configUtils: ConfigUtils) {\n    const { getClassGroupId, getConflictingClassGroupIds } = configUtils\n\n    /**\n     * Set of classGroupIds in following format:\n     * `{importantModifier}{variantModifiers}{classGroupId}`\n     * @example 'float'\n     * @example 'hover:focus:bg-color'\n     * @example 'md:!pr'\n     */\n    const classGroupsInConflict = new Set<string>()\n\n    return (\n        classList\n            .trim()\n            .split(SPLIT_CLASSES_REGEX)\n            .map((originalClassName) => {\n                const { modifiers, hasImportantModifier, baseClassName } =\n                    splitModifiers(originalClassName)\n\n                const classGroupId = getClassGroupId(baseClassName)\n\n                if (!classGroupId) {\n                    return {\n                        isTailwindClass: false as const,\n                        originalClassName,\n                    }\n                }\n\n                const variantModifier = sortModifiers(modifiers).join('')\n\n                const modifierId = hasImportantModifier\n                    ? variantModifier + IMPORTANT_MODIFIER\n                    : variantModifier\n\n                return {\n                    isTailwindClass: true as const,\n                    modifierId,\n                    classGroupId,\n                    originalClassName,\n                }\n            })\n            .reverse()\n            // Last class in conflict wins, so we need to filter conflicting classes in reverse order.\n            .filter((parsed) => {\n                if (!parsed.isTailwindClass) {\n                    return true\n                }\n\n                const { modifierId, classGroupId } = parsed\n\n                const classId = modifierId + classGroupId\n\n                if (classGroupsInConflict.has(classId)) {\n                    return false\n                }\n\n                classGroupsInConflict.add(classId)\n\n                getConflictingClassGroupIds(classGroupId).forEach((group) =>\n                    classGroupsInConflict.add(modifierId + group),\n                )\n\n                return true\n            })\n            .reverse()\n            .map((parsed) => parsed.originalClassName)\n            .join(' ')\n    )\n}\n\nconst SPLIT_MODIFIER_REGEX = /[:[\\]]/g\n\nfunction splitModifiers(className: string) {\n    const modifiers = []\n\n    let bracketDepth = 0\n    let modifierStart = 0\n    let match: RegExpExecArray | null\n\n    while ((match = SPLIT_MODIFIER_REGEX.exec(className))) {\n        if (match[0] === ':') {\n            if (bracketDepth === 0) {\n                const nextModifierStart = match.index! + 1\n                modifiers.push(className.substring(modifierStart, nextModifierStart))\n                modifierStart = nextModifierStart\n            }\n        } else if (match[0] === '[') {\n            bracketDepth++\n        } else if (match[0] === ']') {\n            bracketDepth--\n        }\n    }\n\n    const baseClassNameWithImportantModifier =\n        modifiers.length === 0 ? className : className.substring(modifierStart)\n    const hasImportantModifier = baseClassNameWithImportantModifier.startsWith(IMPORTANT_MODIFIER)\n    const baseClassName = hasImportantModifier\n        ? baseClassNameWithImportantModifier.substring(1)\n        : baseClassNameWithImportantModifier\n\n    return {\n        modifiers,\n        hasImportantModifier,\n        baseClassName,\n    }\n}\n\n/**\n * Sorts modifiers according to following schema:\n * - Predefined modifiers are sorted alphabetically\n * - When an arbitrary variant appears, it must be preserved which modifiers are before and after it\n */\nfunction sortModifiers(modifiers: string[]) {\n    if (modifiers.length <= 1) {\n        return modifiers\n    }\n\n    const sortedModifiers: string[] = []\n    let unsortedModifiers: string[] = []\n\n    modifiers.forEach((modifier) => {\n        const isArbitraryVariant = modifier[0] === '['\n\n        if (isArbitraryVariant) {\n            sortedModifiers.push(...unsortedModifiers.sort(), modifier)\n            unsortedModifiers = []\n        } else {\n            unsortedModifiers.push(modifier)\n        }\n    })\n\n    sortedModifiers.push(...unsortedModifiers.sort())\n\n    return sortedModifiers\n}\n"]},"metadata":{},"sourceType":"module"}